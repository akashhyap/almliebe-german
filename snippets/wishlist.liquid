{% comment %}
  WISHLIST - Advanced Custom Solution with Account Sync
  
  Features:
  - Guest: localStorage storage
  - Logged in: Customer metafield storage (synced across devices)
  - Auto-merge on login
  - No app required
  
  Setup Required:
  1. Create customer metafield definition: custom.wishlist (JSON)
  2. Deploy PHP API to Cloudways
  3. Configure App Proxy in Shopify
  4. Include this snippet in theme.liquid before </body>
{% endcomment %}

<script>
window.AlmliebeWishlist = (function() {
  const STORAGE_KEY = 'almliebe_wishlist';
  const API_ENDPOINT = '/apps/wishlist';
  const DEBUG = true; // Set to false in production
  
  function log(...args) {
    if (DEBUG) console.log('[Wishlist]', ...args);
  }
  
  // Check if customer is logged in
  const isLoggedIn = {{ customer | default: false | json }} !== false;
  const customerId = {{ customer.id | default: 'null' }};
  
  log('Init - Logged in:', isLoggedIn, 'Customer ID:', customerId);
  
  // Customer's saved wishlist from metafield (loaded with page)
  let accountItems = [];
  {%- if customer and customer.metafields.custom.wishlist -%}
    try {
      accountItems = JSON.parse({{ customer.metafields.custom.wishlist | json }}) || [];
      log('Loaded from metafield:', accountItems);
    } catch (e) {
      log('Failed to parse metafield:', e);
      accountItems = [];
    }
  {%- else -%}
    log('No metafield data found');
  {%- endif -%}
  
  // Get items from localStorage
  function getLocalItems() {
    try {
      const items = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
      return items;
    } catch (e) {
      return [];
    }
  }
  
  // Save items to localStorage
  function saveLocalItems(items) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(items));
    log('Saved to localStorage:', items.length, 'items');
  }
  
  // Clear localStorage
  function clearLocalItems() {
    localStorage.removeItem(STORAGE_KEY);
    log('Cleared localStorage');
  }
  
  // Save items to customer metafield via API
  async function saveToAccount(items) {
    if (!isLoggedIn) {
      log('Not logged in, skipping account save');
      return false;
    }
    
    log('Saving to account via API...', items.length, 'items');
    
    try {
      const response = await fetch(API_ENDPOINT, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          action: 'save',
          customer_id: customerId,
          wishlist: items
        })
      });
      
      log('API Response status:', response.status);
      
      const data = await response.json();
      log('API Response data:', data);
      
      if (data.success) {
        accountItems = items; // Update local cache
        log('Account save successful');
        return true;
      }
      
      log('API returned success: false', data.error || '');
      return false;
    } catch (e) {
      console.error('[Wishlist] API save failed:', e);
      return false;
    }
  }
  
  // Get all items (combines localStorage and account for logged-in users)
  function getItems() {
    if (isLoggedIn) {
      // For logged-in users, prefer account items but fallback to localStorage
      // This handles the case where API save failed
      const local = getLocalItems();
      if (accountItems.length > 0) {
        return accountItems;
      } else if (local.length > 0) {
        // Account is empty but localStorage has items - use localStorage
        // (merge probably hasn't happened yet or failed)
        return local;
      }
      return [];
    }
    return getLocalItems();
  }
  
  // Save items (to both localStorage and account if logged in)
  async function saveItems(items) {
    // Always save to localStorage as backup/cache
    saveLocalItems(items);
    
    // If logged in, also save to account
    if (isLoggedIn) {
      const saved = await saveToAccount(items);
      if (saved) {
        log('Saved to both localStorage and account');
      } else {
        log('Account save failed, items preserved in localStorage');
      }
    }
    
    updateCount();
    document.dispatchEvent(new CustomEvent('wishlist:updated', { detail: { items } }));
  }
  
  // Add product
  function add(productId, productHandle, productData) {
    const items = getItems();
    const exists = items.find(item => item.id == productId);
    
    if (!exists) {
      items.push({
        id: String(productId),
        handle: productHandle || '',
        title: productData?.title || '',
        image: productData?.image || '',
        price: productData?.price || '',
        vendor: productData?.vendor || '',
        url: productData?.url || '',
        addedAt: Date.now()
      });
      saveItems(items);
      log('Added product:', productId);
    }
    return items;
  }
  
  // Remove product
  function remove(productId) {
    let items = getItems();
    items = items.filter(item => item.id != productId);
    saveItems(items);
    log('Removed product:', productId);
    return items;
  }
  
  // Toggle product
  function toggle(productId, productHandle, productData) {
    if (contains(productId)) {
      remove(productId);
      return false;
    } else {
      add(productId, productHandle, productData);
      return true;
    }
  }
  
  // Check if product is in wishlist
  function contains(productId) {
    const items = getItems();
    return items.some(item => item.id == productId);
  }
  
  // Get count
  function getCount() {
    return getItems().length;
  }
  
  // Update header count badge
  function updateCount() {
    const count = getCount();
    log('Updating count badge:', count);
    const badges = document.querySelectorAll('[data-wishlist-count]');
    
    badges.forEach(badge => {
      badge.textContent = count;
      if (count > 0) {
        badge.classList.remove('is-hidden');
      } else {
        badge.classList.add('is-hidden');
      }
    });
  }
  
  // Merge localStorage with account on login
  async function mergeWishlists() {
    if (!isLoggedIn) return;
    
    const localItems = getLocalItems();
    log('Merge check - Local items:', localItems.length, 'Account items:', accountItems.length);
    
    // If no local items, nothing to merge
    if (localItems.length === 0) {
      log('No local items to merge');
      return;
    }
    
    // Merge: combine account items with local items (avoiding duplicates)
    const merged = [...accountItems];
    let hasNewItems = false;
    
    localItems.forEach(localItem => {
      if (!merged.some(item => item.id == localItem.id)) {
        merged.push(localItem);
        hasNewItems = true;
        log('Merging item:', localItem.id, localItem.title);
      }
    });
    
    if (hasNewItems) {
      log('Attempting to save merged wishlist:', merged.length, 'items');
      const saved = await saveToAccount(merged);
      
      if (saved) {
        accountItems = merged;
        clearLocalItems(); // Only clear localStorage after successful save
        log('Merge complete - cleared localStorage');
      } else {
        // API failed - keep localStorage items so they're not lost!
        log('Merge failed - keeping localStorage items');
      }
    } else {
      // All items already exist in account, safe to clear localStorage
      log('All items already in account, clearing localStorage');
      clearLocalItems();
    }
  }
  
  // Test API connection
  async function testAPI() {
    log('Testing API connection...');
    try {
      const response = await fetch(API_ENDPOINT + '?action=status');
      const data = await response.json();
      log('API Status:', data);
      return data;
    } catch (e) {
      console.error('[Wishlist] API test failed:', e);
      return { error: e.message };
    }
  }
  
  // Initialize all wishlist buttons
  async function init() {
    log('Initializing wishlist...');
    
    // Test API first (in debug mode)
    if (DEBUG) {
      await testAPI();
    }
    
    // Merge wishlists if logged in
    if (isLoggedIn) {
      await mergeWishlists();
    }
    
    // Set active state for all wishlist buttons
    document.querySelectorAll('[data-wishlist-toggle]').forEach(btn => {
      const productId = btn.dataset.wishlistToggle;
      if (contains(productId)) {
        btn.classList.add('is-active');
      } else {
        btn.classList.remove('is-active');
      }
    });
    
    updateCount();
    log('Initialization complete. Total items:', getCount());
  }
  
  // Public API
  return {
    getItems,
    add,
    remove,
    toggle,
    contains,
    getCount,
    updateCount,
    init,
    isLoggedIn,
    saveItems,
    clearLocalItems,
    testAPI,
    debug: () => ({ isLoggedIn, customerId, accountItems, localItems: getLocalItems() })
  };
})();

// Alias for backwards compatibility
window.Wishlist = window.AlmliebeWishlist;

// Initialize on DOM ready
document.addEventListener('DOMContentLoaded', function() {
  window.AlmliebeWishlist.init();
  
  // Global click handler for wishlist buttons
  document.addEventListener('click', function(e) {
    const wishlistBtn = e.target.closest('[data-wishlist-toggle]');
    if (!wishlistBtn) return;
    
    e.preventDefault();
    e.stopPropagation();
    
    const productId = wishlistBtn.dataset.wishlistToggle;
    const productHandle = wishlistBtn.dataset.productHandle || '';
    
    // Get product data from data attributes
    const productData = {
      title: wishlistBtn.dataset.productTitle || '',
      image: wishlistBtn.dataset.productImage || '',
      price: wishlistBtn.dataset.wishlistPrice || wishlistBtn.dataset.productPrice || '',
      vendor: wishlistBtn.dataset.productVendor || '',
      url: wishlistBtn.dataset.productUrl || ''
    };
    
    const isAdded = window.AlmliebeWishlist.toggle(productId, productHandle, productData);
    
    // Update all buttons for this product
    document.querySelectorAll(`[data-wishlist-toggle="${productId}"]`).forEach(btn => {
      btn.classList.toggle('is-active', isAdded);
      btn.setAttribute('aria-label', isAdded ? 'Von Wunschliste entfernen' : 'Zur Wunschliste hinzufügen');
    });
    
    // Show feedback toast
    showWishlistToast(isAdded);
  });
});

// Toast notification
function showWishlistToast(added) {
  const existing = document.querySelector('.wishlist-toast');
  if (existing) existing.remove();
  
  const toast = document.createElement('div');
  toast.className = 'wishlist-toast';
  toast.innerHTML = `
    <svg width="18" height="18" viewBox="0 0 24 24" fill="${added ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="1.5">
      <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/>
    </svg>
    <span>${added ? 'Zur Wunschliste hinzugefügt' : 'Von Wunschliste entfernt'}</span>
  `;
  document.body.appendChild(toast);
  
  requestAnimationFrame(() => toast.classList.add('is-visible'));
  
  setTimeout(() => {
    toast.classList.remove('is-visible');
    setTimeout(() => toast.remove(), 300);
  }, 2000);
}

document.addEventListener('shopify:section:load', () => window.AlmliebeWishlist.init());
</script>

<style>
  /* ===========================================
     PRODUCT CARD WISHLIST BUTTON
     Smaller size, dark color instead of red
     =========================================== */
  
  .wishlist-btn,
  [data-wishlist-toggle] {
    position: absolute;
    top: 0.75rem;
    right: 0.75rem;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255, 255, 255, 0.9);
    border: none;
    border-radius: 50%;
    cursor: pointer;
    transition: all 0.2s ease;
    z-index: 2;
    padding: 0;
  }
  
  .wishlist-btn:hover,
  [data-wishlist-toggle]:hover {
    background: #FFFFFF;
    transform: scale(1.05);
  }
  
  .wishlist-btn svg,
  [data-wishlist-toggle] svg {
    width: 18px;
    height: 18px;
    stroke: #1a1a1a;
    stroke-width: 1.5;
    fill: none;
    transition: all 0.2s ease;
  }
  
  /* Active state - filled dark heart */
  .wishlist-btn.is-active svg,
  [data-wishlist-toggle].is-active svg {
    fill: #1a1a1a;
    stroke: #1a1a1a;
  }
  
  /* Hover state */
  .wishlist-btn:hover svg,
  [data-wishlist-toggle]:hover svg {
    stroke: #000000;
  }
  
  /* ===========================================
     HEADER WISHLIST ICON
     =========================================== */
  
  .header__wishlist {
    position: relative;
  }
  
  .header__wishlist svg {
    width: 22px;
    height: 22px;
    stroke: currentColor;
    stroke-width: 1.5;
    fill: none;
    transition: all 0.2s;
  }
  
  .header__wishlist:hover svg {
    opacity: 0.6;
  }
  
  /* ===========================================
     WISHLIST COUNT BADGES
     =========================================== */
  
  /* Header count badge - matches cart badge exactly */
  [data-wishlist-count] {
    position: absolute;
    top: 4px;
    right: 2px;
    min-width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 0.25rem;
    font-size: 0.6875rem;
    font-weight: 700;
    background: #000000;
    color: #FFFFFF;
    border-radius: 9px;
  }
  
  /* Hide badge when empty */
  [data-wishlist-count].is-hidden {
    display: none;
  }
  
  /* Mobile wishlist count in mobile menu */
  .mobile-nav-wishlist-count {
    margin-left: auto;
    min-width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 0.375rem;
    font-size: 0.75rem;
    font-weight: 700;
    background: #000000;
    color: #FFFFFF;
    border-radius: 10px;
  }

  .mobile-nav-wishlist-count.is-hidden {
    display: none;
  }
  
  /* ===========================================
     TOAST NOTIFICATION
     =========================================== */
  
  .wishlist-toast {
    position: fixed;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%) translateY(100%);
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1.25rem;
    background: #1a1a1a;
    color: #FFFFFF;
    border-radius: 9999px;
    font-size: 0.8125rem;
    font-weight: 500;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    z-index: 9999;
    opacity: 0;
    transition: all 0.3s ease;
  }
  
  .wishlist-toast.is-visible {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
  }
  
  .wishlist-toast svg {
    flex-shrink: 0;
  }
</style>
